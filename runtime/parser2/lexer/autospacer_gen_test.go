//go:generate go test -tags=generate -test.run=GenerateTokenPairsThatNeedSpacing -test.count=1 .
//go:build generate
// +build generate

/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2021 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lexer

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
	"testing"
)

func TestOrGenerateTokenPairsThatNeedSpacing(t *testing.T) {
	var gosrc bytes.Buffer

	var tokenPairsThatNeedSpacing [TokenMax][TokenMax]bool
	var tokenPairsThatCanNeverOccur [TokenMax][TokenMax]bool

	for want1 := TokenSpace; want1 < TokenLineComment; want1++ {
		for want2 := TokenSpace; want2 < TokenLineComment; want2++ {
			wantEOF := TokenEOF
			lex := Lex(ttxt(want1) + ttxt(want2))
			have1, have2, haveEOF := lex.Next().Type, lex.Next().Type, lex.Next().Type

			if want1 != have1 || want2 != have2 || wantEOF != haveEOF {
				// probably needs a space between want1 and want2
				// does adding a space in between make it lex properly?
				spaced := ttxt(want1) + " " + ttxt(want2)

				lex = Lex(spaced)
				have1, haveSpace, have2, haveEOF := lex.Next().Type, lex.Next().Type, lex.Next().Type, lex.Next().Type

				if want1 == have1 && TokenSpace == haveSpace && want2 == have2 && wantEOF == haveEOF {
					tokenPairsThatNeedSpacing[want1][want2] = true
				} else {
					tokenPairsThatCanNeverOccur[want1][want2] = true
				}
			}
		}
	}

	gosrc.WriteString("// Code generated by autospacer_gen_test.go. DO NOT EDIT.\n\n")
	gosrc.WriteString("// Copyright 2021 Dapper Labs, Inc. see http://www.apache.org/licenses/LICENSE-2.0\n\n")
	gosrc.WriteString("package lexer\n\n")

	gosrc.WriteString("const \u03a4 = true\nconst \u1D17 = false\n")

	writeTable := func(table [TokenMax][TokenMax]bool, tableName string) {
		gosrc.WriteString("var " + tableName + " = [TokenMax][TokenMax]bool{\n")
		for type1 := TokenType(0); type1 < TokenMax; type1++ {
			gosrc.WriteString(fmt.Sprintf("\t/*%2d:*/ {", int(type1)))
			for type2 := TokenType(0); type2 < TokenMax; type2++ {
				if table[type1][type2] {
					gosrc.WriteString("\u03A4,")
				} else {
					gosrc.WriteString("\u1D17,")
				}
			}
			gosrc.WriteString("},\n")
		}
		gosrc.WriteString("}\n")
	}

	writeTable(tokenPairsThatNeedSpacing, "tokenPairsThatNeedSpacing")
	writeTable(tokenPairsThatCanNeverOccur, "tokenPairsThatCanNeverOccur")

	if err := ioutil.WriteFile("autospacer_gen_data.go", gosrc.Bytes(), 0644); err != nil {
		panic(err)
	}
}

var ttxtMap = map[TokenType]string{
	TokenSpace:                     " ",
	TokenIdentifier:                "id",
	TokenString:                    "\"string\"",
	TokenLineComment:               "//comment",
	TokenBlockCommentContent:       "block comment",
	TokenBinaryIntegerLiteral:      "0b0",
	TokenOctalIntegerLiteral:       "0o0",
	TokenDecimalIntegerLiteral:     "000",
	TokenHexadecimalIntegerLiteral: "0x0",
	TokenFixedPointNumberLiteral:   "0.0",
	TokenUnknownBaseIntegerLiteral: "0U0",
}

func ttxt(t TokenType) string {
	if text, ok := ttxtMap[t]; ok {
		return text
	}
	text := fmt.Sprint(t)
	if text[0] != '\'' {
		panic("unexpected TokenType.text = " + text)
	}
	return strings.Trim(text, "'")
}
